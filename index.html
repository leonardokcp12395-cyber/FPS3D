<!DOCTYPE html>
<html lang="pt">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Jogo FPS 3D (Versão Final Corrigida)</title>
    <style>
        html, body {
            overflow: hidden;
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #000;
        }

        #renderCanvas {
            width: 100%;
            height: 100%;
            touch-action: none;
        }
        
        /* --- Interface do Jogo (HUD) --- */
        #hud {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            color: white;
            z-index: 10;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        #top-hud {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            padding: 10px;
            font-size: 1em;
            text-shadow: 1px 1px 2px black;
        }

        .hud-box {
            background-color: rgba(0,0,0,0.6);
            padding: 8px 12px;
            border-radius: 5px;
        }
        #score-info { font-size: 1.2em; font-weight: bold; }

        #bottom-hud {
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
            padding: 15px;
        }

        #health-bar-container { width: 150px; height: 20px; background-color: rgba(255, 0, 0, 0.3); border: 1px solid rgba(255,255,255,0.5); border-radius: 5px; }
        #health-bar { width: 100%; height: 100%; background-color: #4CAF50; transition: width 0.2s ease-out; }
        
        #ammo-info { font-size: 2em; font-weight: bold; text-shadow: 2px 2px 4px black; }
        #ammo-info span { font-size: 0.6em; font-weight: normal; }
        
        #center-hud {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -150px);
            text-align: center;
        }
        #reloading-text, #wave-text, #paused-text, #sprint-indicator, #powerup-text {
            font-size: 1.5em; text-shadow: 2px 2px 4px black; display: none;
        }
        #wave-text { font-size: 2.5em; }

        /* Mira Dinâmica */
        .crosshair { position: absolute; top: 50%; left: 50%; width: 2px; height: 20px; background-color: rgba(255, 255, 255, 0.8); transform: translate(-50%, -50%); transition: height 0.2s ease, width 0.2s ease; }
        .crosshair::after { content: ''; position: absolute; top: 50%; left: 50%; width: 20px; height: 2px; background-color: rgba(255, 255, 255, 0.8); transform: translate(-50%, -50%); transition: width 0.2s ease, height 0.2s ease; }
        .crosshair.moving { height: 30px; }
        .crosshair.moving::after { width: 30px; }
        #hit-marker { position: absolute; top: 50%; left: 50%; width: 15px; height: 15px; transform: translate(-50%, -50%) rotate(45deg); border: 2px solid red; opacity: 0; transition: opacity 0.2s; }

        /* Efeitos Visuais */
        #damage-flash { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: red; opacity: 0; pointer-events: none; z-index: 15; transition: opacity 0.5s; }
        #low-health-vignette { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 16; opacity: 0; box-shadow: inset 0 0 100px 20px rgba(255, 0, 0, 0.5); animation: pulse 1s infinite; display: none; }
        @keyframes pulse { 0% { opacity: 0.5; } 50% { opacity: 0.8; } 100% { opacity: 0.5; } }

        /* Telas de Overlay */
        .overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; justify-content: center; align-items: center; background-color: rgba(0, 0, 0, 0.8); color: white; text-align: center; cursor: pointer; z-index: 20; }
        .overlay-content { padding: 20px 40px; border-radius: 10px; }
        #win-screen, #gameover-screen { display: none; }
    </style>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
    <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
    <script src="https://cdn.babylonjs.com/postProcesses/babylon.postProcess.min.js"></script>
</head>
<body>
    <div id="hud">
        <div id="top-hud">
            <div id="score-info" class="hud-box">Pontos: 0</div>
            <div id="wave-info" class="hud-box"></div>
        </div>
        <div id="center-hud">
            <div id="reloading-text">A RECARREGAR...</div>
            <div id="wave-text"></div>
            <div id="sprint-indicator">A CORRER</div>
            <div id="powerup-text"></div>
        </div>
        <div id="bottom-hud">
            <div id="health-bar-container"><div id="health-bar"></div></div>
            <div id="ammo-info"></div>
        </div>
    </div>
    <div class="crosshair"></div>
    <div id="hit-marker"></div>
    <div id="damage-flash"></div>
    <div id="low-health-vignette"></div>

    <div id="start-screen" class="overlay">
        <div class="overlay-content">
            <h1>Versão Melhorada</h1>
            <p>Use os controlos no ecrã para jogar.</p>
            <p>Mantenha 'Atirar' pressionado para disparo automático.</p>
            <h2>Toque para começar!</h2>
        </div>
    </div>
    <div id="win-screen" class="overlay"><div class="overlay-content"><h1>Você Venceu!</h1><p>Toque para jogar novamente.</p></div></div>
    <div id="gameover-screen" class="overlay"><div class="overlay-content"><h1>Fim de Jogo</h1><p>Toque para tentar novamente.</p></div></div>

    <canvas id="renderCanvas"></canvas>

    <script>
        window.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('renderCanvas');
            const hudElements = {
                start: document.getElementById('start-screen'),
                win: document.getElementById('win-screen'),
                gameOver: document.getElementById('gameover-screen'),
                score: document.getElementById('score-info'),
                wave: document.getElementById('wave-info'),
                health: document.getElementById('health-bar'),
                ammo: document.getElementById('ammo-info'),
                reloading: document.getElementById('reloading-text'),
                waveText: document.getElementById('wave-text'),
                sprintIndicator: document.getElementById('sprint-indicator'),
                powerupText: document.getElementById('powerup-text'),
                damageFlash: document.getElementById('damage-flash'),
                lowHealthVignette: document.getElementById('low-health-vignette'),
                hitMarker: document.getElementById('hit-marker'),
                crosshair: document.querySelector('.crosshair'),
            };

            const engine = new BABYLON.Engine(canvas, true, { adaptToDeviceRatio: true });
            const scene = new BABYLON.Scene(engine);
            scene.gravity = new BABYLON.Vector3(0, -0.9, 0);
            scene.collisionsEnabled = true;

            let gameState = 'start';
            const playerState = { 
                health: 100, maxHealth: 100, ammo: 30, clipSize: 30, totalAmmo: 90,
                isReloading: false, isFiring: false, walkSpeed: 0.25, sprintSpeed: 0.45, isMoving: false,
                score: 0, damageMultiplier: 1, lastShotTime: 0, fireRate: 120,
                shockwaveReady: true, shockwaveCooldown: 10000
            };
            const waveConfig = [ { normal: 2, scout: 1, brute: 0 }, { normal: 3, scout: 2, brute: 1 }, { normal: 4, scout: 4, brute: 2 } ];
            let currentWave = 0;
            const enemies = [];
            let targetsRemaining = 0;
            let shadowGenerator;
            let postProcess;
            let weapon;
            let particleSystems = {};
            let lastStepTime = 0;
            let skybox;
            let activeTimeouts = [];
            let pillarMeshes = [];

            const sounds = {
                shoot: new BABYLON.Sound("shoot", "https://assets.babylonjs.com/sound/gun.wav", scene),
                explosion: new BABYLON.Sound("explosion", "https://assets.babylonjs.com/sound/explosion.wav", scene),
                playerHit: new BABYLON.Sound("playerHit", "https://assets.babylonjs.com/sound/hit.wav", scene),
                reload: new BABYLON.Sound("reload", "https://assets.babylonjs.com/sound/reload.wav", scene),
                pickup: new BABYLON.Sound("pickup", "https://assets.babylonjs.com/sound/pickup.wav", scene),
                empty: new BABYLON.Sound("empty", "https://assets.babylonjs.com/sound/click.wav", scene),
                footstep: new BABYLON.Sound("footstep", "https://assets.babylonjs.com/sound/footstep_carpet.wav", scene, null, { loop: false, volume: 0.3 }),
                shockwave: new BABYLON.Sound("shockwave", "https://assets.babylonjs.com/sound/explosion.wav", scene, null, { volume: 0.5 })
            };

            const camera = new BABYLON.FreeCamera('camera1', new BABYLON.Vector3(0, 2, -15), scene);
            camera.checkCollisions = true;
            camera.applyGravity = true;
            camera.ellipsoid = new BABYLON.Vector3(0.5, 0.9, 0.5);
            camera.speed = playerState.walkSpeed;
            camera.angularSensibility = 4000;
            camera.inputs.addVirtualJoysticks();

            function createEnvironment() {
                skybox = BABYLON.MeshBuilder.CreateBox("skyBox", { size: 1000.0 }, scene);
                const skyboxMaterial = new BABYLON.StandardMaterial("skyBox", scene);
                skyboxMaterial.backFaceCulling = false;
                skyboxMaterial.reflectionTexture = new BABYLON.CubeTexture("https://www.babylonjs-playground.com/textures/skybox", scene);
                skyboxMaterial.reflectionTexture.coordinatesMode = BABYLON.Texture.SKYBOX_MODE;
                skybox.material = skyboxMaterial;

                const light = new BABYLON.DirectionalLight("dir01", new BABYLON.Vector3(-1, -2, -1), scene);
                light.position = new BABYLON.Vector3(20, 40, 20);
                shadowGenerator = new BABYLON.ShadowGenerator(1024, light);
                shadowGenerator.usePoissonSampling = true;

                const ground = BABYLON.MeshBuilder.CreateGround('ground', { width: 100, height: 100 }, scene);
                ground.checkCollisions = true;
                const groundMaterial = new BABYLON.StandardMaterial("groundMat", scene);
                const groundTexture = new BABYLON.Texture("https://www.babylonjs-playground.com/textures/sand.jpg", scene);
                groundMaterial.diffuseTexture = groundTexture;
                groundMaterial.bumpTexture = new BABYLON.Texture("https://www.babylonjs-playground.com/textures/sand-normal.png", scene);
                groundTexture.uScale = 10;
                groundTexture.vScale = 10;
                ground.material = groundMaterial;
                ground.receiveShadows = true;

                for(let i = 0; i < 8; i++) {
                    const height = Math.random() * 6 + 2;
                    const pillar = BABYLON.MeshBuilder.CreateBox(`pillar${i}`, {width: 2, depth: 2, height: height}, scene);
                    pillar.position = new BABYLON.Vector3(Math.random() * 70 - 35, height / 2, Math.random() * 70 - 35);
                    pillar.checkCollisions = true;
                    shadowGenerator.addShadowCaster(pillar);
                    pillarMeshes.push(pillar);
                }
                const staticMeshes = [ground, ...pillarMeshes];
                staticMeshes.forEach(m => m.freezeWorldMatrix());
                
                postProcess = new BABYLON.DefaultRenderingPipeline("default", true, scene, [camera]);
                postProcess.bloomEnabled = true;
                postProcess.bloomThreshold = 0.5;
                postProcess.bloomWeight = 0.5;
                postProcess.fxaaEnabled = true;
            }

            function createWeapon() {
                weapon = new BABYLON.TransformNode("weapon", scene);
                weapon.parent = camera;
                weapon.position = new BABYLON.Vector3(0.3, -0.45, 0.6);

                const weaponBody = BABYLON.MeshBuilder.CreateBox("weaponBody", {width: 0.1, height: 0.2, depth: 0.6}, scene);
                weaponBody.parent = weapon;

                const muzzleFlash = BABYLON.MeshBuilder.CreatePlane("muzzleFlash", {size: 0.2}, scene);
                muzzleFlash.parent = weapon;
                muzzleFlash.position.z = 0.35;
                const flashMaterial = new BABYLON.StandardMaterial("flashMat", scene);
                flashMaterial.emissiveTexture = new BABYLON.Texture("https://www.babylonjs-playground.com/textures/flare.png", scene);
                flashMaterial.opacityTexture = flashMaterial.emissiveTexture;
                flashMaterial.disableLighting = true;
                muzzleFlash.material = flashMaterial;
                muzzleFlash.setEnabled(false);
                weapon.muzzleFlash = muzzleFlash;
            }
            
            // Animações criadas uma vez para reutilização
            const recoilAnim = new BABYLON.Animation("recoil", "position.z", 30, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE);
            recoilAnim.setKeys([ { frame: 0, value: 0.6 }, { frame: 3, value: 0.5 }, { frame: 8, value: 0.6 } ]);

            const shootShakeAnim = new BABYLON.Animation("camShake", "rotation.x", 30, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE);

            function createEnemy(id, type) {
                const enemyRoot = new BABYLON.TransformNode("enemyRoot" + id, scene);
                const bodyMaterial = new BABYLON.StandardMaterial("enemyMat", scene);
                let patrolSpeed, health, body;

                if (type === 'scout') {
                    body = BABYLON.MeshBuilder.CreateCylinder("enemyBody", {height: 1.5, diameter: 1}, scene);
                    bodyMaterial.diffuseColor = new BABYLON.Color3(0.4, 0.6, 1.0);
                    patrolSpeed = 0.08;
                    health = 30;
                } else if (type === 'brute') {
                    body = BABYLON.MeshBuilder.CreateCylinder("enemyBody", {height: 2.5, diameter: 2}, scene);
                    bodyMaterial.diffuseColor = new BABYLON.Color3(0.8, 0.4, 1.0);
                    patrolSpeed = 0.02;
                    health = 100;
                } else {
                    body = BABYLON.MeshBuilder.CreateCylinder("enemyBody", {height: 2, diameter: 1.5}, scene);
                    bodyMaterial.diffuseColor = new BABYLON.Color3(0.5, 0.5, 0.6);
                    patrolSpeed = 0.04;
                    health = 50;
                }
                body.parent = enemyRoot;
                body.material = bodyMaterial;
                
                const eye = BABYLON.MeshBuilder.CreateSphere("enemyEye", {diameter: 0.6}, scene);
                eye.parent = enemyRoot;
                eye.position.z = -body.scaling.z * 0.7;
                eye.position.y = 0.4;
                const eyeMaterial = new BABYLON.StandardMaterial("eyeMat", scene);
                eyeMaterial.emissiveColor = new BABYLON.Color3(1, 0, 0);
                eye.material = eyeMaterial;

                enemyRoot.position = new BABYLON.Vector3(Math.random() * 80 - 40, 1.5, Math.random() * 80 - 40);
                shadowGenerator.addShadowCaster(enemyRoot);
                
                enemies.push({
                    mesh: enemyRoot, type: type, state: 'patrol',
                    patrolDirection: new BABYLON.Vector3(Math.random() - 0.5, 0, Math.random() - 0.5).normalize(),
                    patrolSpeed: patrolSpeed, attackCooldown: 2.5, lastAttackTime: 0, health: health,
                    strafeTime: 0, strafeDirection: 1, isAlive: true
                });
            }

            function createParticleSystem(name, texture, scene) {
                const ps = new BABYLON.ParticleSystem(name, 2000, scene);
                ps.particleTexture = new BABYLON.Texture(texture, scene);
                ps.minEmitBox = new BABYLON.Vector3(-0.1, -0.1, -0.1);
                ps.maxEmitBox = new BABYLON.Vector3(0.1, 0.1, 0.1);
                ps.minSize = 0.1;
                ps.maxSize = 0.5;
                ps.minLifeTime = 0.2;
                ps.maxLifeTime = 0.5;
                ps.emitRate = 1000;
                ps.gravity = new BABYLON.Vector3(0, -9.81, 0);
                ps.targetStopDuration = 0.2;
                return ps;
            }

            function playParticleSystem(name, emitter) {
                if (!particleSystems[name]) {
                    const texture = name === 'explosion' ? "https://www.babylonjs-playground.com/textures/flare.png" : "https://www.babylonjs-playground.com/textures/spark_2.png";
                    particleSystems[name] = createParticleSystem(name, texture, scene);
                }
                const ps = particleSystems[name];
                if (ps.isStarted()) ps.stop();
                ps.emitter = emitter;
                ps.start();
            }

            function enemyShoot(enemy) {
                 if(scene.isDisposed) return;
                const projectile = BABYLON.MeshBuilder.CreateSphere(`proj_${enemy.mesh.name}`, {diameter: enemy.type === 'brute' ? 0.6 : 0.3}, scene);
                projectile.position = enemy.mesh.position.clone();
                const direction = camera.position.subtract(enemy.mesh.position).normalize();
                
                projectile.actionManager = new BABYLON.ActionManager(scene);
                projectile.actionManager.registerAction(
                    new BABYLON.ExecuteCodeAction(
                        { trigger: BABYLON.ActionManager.OnIntersectionEnterTrigger, parameter: { mesh: camera, usePreciseIntersection: true } },
                        () => { playerTakeDamage(enemy.type === 'brute' ? 25 : 10); projectile.dispose(); }
                    )
                );
                pillarMeshes.forEach(pillar => {
                    projectile.actionManager.registerAction(
                        new BABYLON.ExecuteCodeAction(
                            { trigger: BABYLON.ActionManager.OnIntersectionEnterTrigger, parameter: pillar },
                            () => { projectile.dispose(); }
                        )
                    );
                });
                
                const moveProjectile = () => {
                    if (projectile.isDisposed()) {
                        scene.onBeforeRenderObservable.removeCallback(moveProjectile);
                        return;
                    }
                    projectile.position.addInPlace(direction.scale(enemy.type === 'brute' ? 0.4 : 0.7));
                    if (projectile.position.length() > 200) projectile.dispose();
                };
                scene.onBeforeRenderObservable.add(moveProjectile);
            }
            
            function createPickup(type, position) {
                if(scene.isDisposed) return;
                const pickup = BABYLON.MeshBuilder.CreateBox(type + "Pickup", {size: 0.7}, scene);
                const mat = new BABYLON.StandardMaterial(type + "Mat", scene);
                if (type === 'health') { mat.emissiveColor = new BABYLON.Color3(1, 0, 0); }
                else if (type === 'ammo') { mat.emissiveColor = new BABYLON.Color3(0, 0.5, 1); }
                else if (type === 'damage') { mat.emissiveColor = new BABYLON.Color3(1, 0.5, 0); }
                else if (type === 'speed') { mat.emissiveColor = new BABYLON.Color3(0, 1, 0.5); }
                pickup.material = mat;
                pickup.position = position;
                
                pickup.actionManager = new BABYLON.ActionManager(scene);
                pickup.actionManager.registerAction(
                    new BABYLON.ExecuteCodeAction(
                        { trigger: BABYLON.ActionManager.OnIntersectionEnterTrigger, parameter: camera },
                        () => {
                            sounds.pickup.play();
                            activatePowerUp(type);
                            pickup.dispose();
                        }
                    )
                );

                const rotatePickup = () => {
                    if (pickup.isDisposed()) {
                        scene.onBeforeRenderObservable.removeCallback(rotatePickup);
                        return;
                    }
                    pickup.rotation.y += 0.02;
                }
                scene.onBeforeRenderObservable.add(rotatePickup);
            }

            function activatePowerUp(type) {
                hudElements.powerupText.style.display = 'block';
                let duration = 5000;

                if (type === 'health') {
                    playerState.health = Math.min(playerState.maxHealth, playerState.health + 25);
                    hudElements.powerupText.textContent = "+25 VIDA";
                    duration = 2000;
                } else if (type === 'ammo') {
                    playerState.totalAmmo += playerState.clipSize;
                    hudElements.powerupText.textContent = "+30 MUNIÇÃO";
                    duration = 2000;
                } else if (type === 'damage') {
                    playerState.damageMultiplier = 2;
                    hudElements.powerupText.textContent = "DANO A DOBRAR!";
                    const timeoutId = setTimeout(() => { playerState.damageMultiplier = 1; }, duration);
                    activeTimeouts.push(timeoutId);
                } else if (type === 'speed') {
                    playerState.walkSpeed *= 1.5;
                    playerState.sprintSpeed *= 1.5;
                    camera.speed = playerState.walkSpeed;
                    hudElements.powerupText.textContent = "VELOCIDADE AUMENTADA!";
                    const timeoutId = setTimeout(() => {
                        playerState.walkSpeed /= 1.5;
                        playerState.sprintSpeed /= 1.5;
                    }, duration);
                    activeTimeouts.push(timeoutId);
                }
                updateHUD();
                const timeoutId = setTimeout(() => { hudElements.powerupText.style.display = 'none'; }, duration);
                activeTimeouts.push(timeoutId);
            }

            function playerTakeDamage(amount) {
                if (gameState !== 'playing') return;
                if (navigator.vibrate) navigator.vibrate(100);
                playerState.health -= amount;
                sounds.playerHit.play();
                updateHUD();
                
                hudElements.damageFlash.style.opacity = '0.5';
                const timeoutId = setTimeout(() => { hudElements.damageFlash.style.opacity = '0'; }, 100);
                activeTimeouts.push(timeoutId);

                if (playerState.health <= 0) {
                    playerState.health = 0;
                    updateHUD();
                    gameState = 'gameover';
                    hudElements.gameOver.style.display = 'flex';
                }
            }

            function updateHUD() {
                hudElements.score.textContent = `Pontos: ${playerState.score}`;
                hudElements.wave.textContent = `Vaga: ${currentWave + 1} / ${waveConfig.length}`;
                const healthPercent = (playerState.health / playerState.maxHealth) * 100;
                hudElements.health.style.width = `${healthPercent}%`;
                if(healthPercent <= 0) {
                     hudElements.health.style.backgroundColor = 'transparent';
                } else if(healthPercent < 30) {
                    hudElements.health.style.backgroundColor = '#D32F2F';
                    hudElements.lowHealthVignette.style.display = 'block';
                    if(skybox) skybox.material.reflectionTexture.level = 1.5;
                } else {
                    hudElements.health.style.backgroundColor = '#4CAF50';
                    hudElements.lowHealthVignette.style.display = 'none';
                    if(skybox) skybox.material.reflectionTexture.level = 1.0;
                }
                hudElements.ammo.innerHTML = `${playerState.ammo} <span>/ ${playerState.totalAmmo}</span>`;
            }

            function playerShoot() {
                const currentTime = performance.now();
                if (playerState.isReloading || gameState !== 'playing' || currentTime - playerState.lastShotTime < playerState.fireRate) return;
                if (playerState.ammo <= 0) { if(!playerState.isReloading) { sounds.empty.play(); }; return; }
                
                playerState.lastShotTime = currentTime;
                if (navigator.vibrate) navigator.vibrate(25);
                sounds.shoot.play();
                
                scene.beginDirectAnimation(weapon, [recoilAnim], 0, 8, false, 1);
                
                const currentRotation = camera.rotation.x;
                shootShakeAnim.setKeys([
                    { frame: 0, value: currentRotation }, { frame: 1, value: currentRotation - 0.01 }, { frame: 5, value: currentRotation }
                ]);
                scene.beginDirectAnimation(camera, [shootShakeAnim], 0, 5, false, 1);

                weapon.muzzleFlash.setEnabled(true);
                const timeoutId = setTimeout(() => weapon.muzzleFlash.setEnabled(false), 60);
                activeTimeouts.push(timeoutId);

                playerState.ammo--;
                updateHUD();

                const ray = camera.getForwardRay(200);
                const hit = scene.pickWithRay(ray);

                if (hit && hit.pickedMesh) {
                    if (hit.pickedMesh.name.startsWith("enemy")) {
                        const enemy = enemies.find(e => e.isAlive && e.mesh === hit.pickedMesh.parent);
                        if (enemy) {
                            hudElements.hitMarker.style.opacity = '1';
                            const timeoutId = setTimeout(() => { hudElements.hitMarker.style.opacity = '0'; }, 150);
                            activeTimeouts.push(timeoutId);
                            enemy.health -= 25 * playerState.damageMultiplier;
                            
                            const distance = Math.floor(hit.distance);
                            playerState.score += 10 + Math.max(0, 50 - distance);

                            if (enemy.health <= 0) {
                                enemy.isAlive = false;
                                sounds.explosion.play();
                                playParticleSystem('explosion', enemy.mesh.position);
                                
                                const rand = Math.random();
                                if (rand < 0.1) createPickup('damage', enemy.mesh.position.clone());
                                else if (rand < 0.2) createPickup('speed', enemy.mesh.position.clone());
                                else if (rand < 0.4) createPickup('health', enemy.mesh.position.clone());

                                const deathAnim = new BABYLON.Animation("death", "scaling", 30, BABYLON.Animation.ANIMATIONTYPE_VECTOR3);
                                deathAnim.setKeys([
                                    { frame: 0, value: enemy.mesh.scaling.clone() },
                                    { frame: 10, value: new BABYLON.Vector3(0, 0, 0) }
                                ]);
                                scene.beginDirectAnimation(enemy.mesh, [deathAnim], 0, 10, false, 1, () => {
                                    enemy.mesh.dispose();
                                });
                                
                                targetsRemaining--;
                                playerState.score += 50;
                                updateHUD();
                                if (targetsRemaining <= 0) checkWaveCompletion();
                            }
                        }
                    } else if (hit.pickedPoint) {
                        playParticleSystem('impact', hit.pickedPoint);
                    }
                }
            }
            
            function reloadWeapon() {
                if (playerState.isReloading || playerState.ammo === playerState.clipSize || playerState.totalAmmo === 0 || gameState !== 'playing') return;
                playerState.isReloading = true;
                sounds.reload.play();
                hudElements.reloading.style.display = 'block';
                
                const timeoutId = setTimeout(() => {
                    const ammoNeeded = playerState.clipSize - playerState.ammo;
                    const ammoToReload = Math.min(ammoNeeded, playerState.totalAmmo);
                    playerState.ammo += ammoToReload;
                    playerState.totalAmmo -= ammoToReload;
                    playerState.isReloading = false;
                    hudElements.reloading.style.display = 'none';
                    updateHUD();
                }, 1500);
                activeTimeouts.push(timeoutId);
            }
            
            function useShockwave(button) {
                if (!playerState.shockwaveReady || gameState !== 'playing') return;
                playerState.shockwaveReady = false;
                sounds.shockwave.play();
                if (navigator.vibrate) navigator.vibrate([50, 50, 50]);

                const shockwaveSphere = BABYLON.MeshBuilder.CreateSphere("shockwave", {diameter: 1}, scene);
                shockwaveSphere.position = camera.position.clone();
                shockwaveSphere.isPickable = false;
                const shockwaveMat = new BABYLON.StandardMaterial("shockwaveMat", scene);
                shockwaveMat.emissiveColor = new BABYLON.Color3(0.5, 0.8, 1);
                shockwaveMat.alpha = 0.5;
                shockwaveSphere.material = shockwaveMat;

                const anim = new BABYLON.Animation("shockwaveAnim", "scaling", 30, BABYLON.Animation.ANIMATIONTYPE_VECTOR3);
                anim.setKeys([ { frame: 0, value: new BABYLON.Vector3(1, 1, 1) }, { frame: 15, value: new BABYLON.Vector3(40, 40, 40) } ]);
                scene.beginDirectAnimation(shockwaveSphere, [anim], 0, 15, false, 1, () => shockwaveSphere.dispose());
                
                enemies.forEach(enemy => {
                    if (enemy.isAlive) {
                        const direction = enemy.mesh.position.subtract(camera.position).normalize();
                        enemy.mesh.position.addInPlace(direction.scale(10));
                    }
                });

                let cooldownTimer = playerState.shockwaveCooldown;
                button.background = "grey";
                
                const updateCooldown = () => {
                    if(scene.isDisposed) return;
                    if (gameState === 'playing') {
                        cooldownTimer -= engine.getDeltaTime();
                        button.textBlock.text = Math.ceil(cooldownTimer / 1000).toString();
                    }
                    if (cooldownTimer <= 0) {
                        playerState.shockwaveReady = true;
                        button.background = "rgba(255, 255, 255, 0.2)";
                        button.textBlock.text = "💥";
                        scene.onBeforeRenderObservable.removeCallback(updateCooldown);
                    }
                };
                scene.onBeforeRenderObservable.add(updateCooldown);
            }

            function startNextWave() {
                hudElements.waveText.textContent = `Vaga ${currentWave + 1}`;
                hudElements.waveText.style.display = 'block';
                const timeoutId = setTimeout(() => { hudElements.waveText.style.display = 'none'; }, 2000);
                activeTimeouts.push(timeoutId);

                const waveData = waveConfig[currentWave];
                targetsRemaining = waveData.normal + waveData.scout + waveData.brute;
                for (let i = 0; i < waveData.normal; i++) createEnemy(i, 'normal');
                for (let i = 0; i < waveData.scout; i++) createEnemy(i + waveData.normal, 'scout');
                for (let i = 0; i < waveData.brute; i++) createEnemy(i + waveData.normal + waveData.scout, 'brute');
                updateHUD();
            }

            function checkWaveCompletion() {
                if (currentWave >= waveConfig.length - 1) {
                    gameState = 'win';
                    hudElements.win.style.display = 'flex';
                } else {
                    currentWave++;
                    hudElements.waveText.textContent = 'Vaga Concluída!';
                    hudElements.waveText.style.display = 'block';
                    const timeoutId = setTimeout(() => {
                        hudElements.waveText.style.display = 'none';
                        startNextWave();
                    }, 3000);
                    activeTimeouts.push(timeoutId);
                }
            }

            function cleanUpScene() {
                enemies.forEach(e => { if(e.mesh) e.mesh.dispose(); });
                enemies.length = 0;
                scene.meshes.forEach(mesh => {
                    if (mesh.name.includes("Pickup") || mesh.name.includes("proj_")) {
                        mesh.dispose();
                    }
                });
                Object.values(particleSystems).forEach(ps => ps.dispose());
                particleSystems = {};
                activeTimeouts.forEach(timeoutId => clearTimeout(timeoutId));
                activeTimeouts = [];
            }

            function initGame() {
                cleanUpScene();
                
                for (let i = 0; i < 5; i++) {
                    createPickup('ammo', new BABYLON.Vector3(Math.random() * 80 - 40, 1, Math.random() * 80 - 40));
                }
                
                playerState.health = playerState.maxHealth;
                playerState.ammo = playerState.clipSize;
                playerState.totalAmmo = 90;
                playerState.isReloading = false;
                playerState.isFiring = false;
                playerState.score = 0;
                currentWave = 0;
                
                camera.position = new BABYLON.Vector3(0, 2, -15);
                camera.rotation = new BABYLON.Vector3(0, 0, 0);
                
                startNextWave();
                updateHUD();
            }
            
            function createMobileUI() {
                const advancedTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");
                advancedTexture.isForeground = false;

                const shootButton = BABYLON.GUI.Button.CreateSimpleButton("shoot", "Atirar");
                shootButton.widthInPixels = 150;
                shootButton.heightInPixels = 150;
                shootButton.color = "white";
                shootButton.cornerRadius = 75;
                shootButton.background = "rgba(255, 255, 255, 0.2)";
                shootButton.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;
                shootButton.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_BOTTOM;
                shootButton.rightInPixels = 30;
                shootButton.bottomInPixels = 30;
                shootButton.onPointerDownObservable.add(() => { playerState.isFiring = true; });
                shootButton.onPointerUpObservable.add(() => { playerState.isFiring = false; });
                shootButton.onPointerOutObservable.add(() => { playerState.isFiring = false; });
                advancedTexture.addControl(shootButton);

                const reloadButton = BABYLON.GUI.Button.CreateSimpleButton("reload", "R");
                reloadButton.widthInPixels = 80;
                reloadButton.heightInPixels = 80;
                reloadButton.color = "white";
                reloadButton.cornerRadius = 40;
                reloadButton.background = "rgba(255, 255, 255, 0.2)";
                reloadButton.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;
                reloadButton.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_BOTTOM;
                reloadButton.rightInPixels = 50;
                reloadButton.bottomInPixels = 200;
                reloadButton.onPointerDownObservable.add(reloadWeapon);
                advancedTexture.addControl(reloadButton);

                const sprintButton = BABYLON.GUI.Button.CreateSimpleButton("sprint", "Correr");
                sprintButton.widthInPixels = 100;
                sprintButton.heightInPixels = 100;
                sprintButton.color = "white";
                sprintButton.cornerRadius = 50;
                sprintButton.background = "rgba(255, 255, 255, 0.2)";
                sprintButton.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
                sprintButton.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_BOTTOM;
                sprintButton.leftInPixels = 30;
                sprintButton.bottomInPixels = 30;
                sprintButton.onPointerDownObservable.add(() => {
                    camera.speed = playerState.sprintSpeed;
                    hudElements.sprintIndicator.style.display = 'block';
                });
                 sprintButton.onPointerUpObservable.add(() => {
                    camera.speed = playerState.walkSpeed;
                    hudElements.sprintIndicator.style.display = 'none';
                });
                advancedTexture.addControl(sprintButton);

                const shockwaveButton = BABYLON.GUI.Button.CreateSimpleButton("shockwave", "💥");
                shockwaveButton.widthInPixels = 80;
                shockwaveButton.heightInPixels = 80;
                shockwaveButton.color = "white";
                shockwaveButton.cornerRadius = 40;
                shockwaveButton.background = "rgba(255, 255, 255, 0.2)";
                shockwaveButton.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
                shockwaveButton.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_BOTTOM;
                shockwaveButton.leftInPixels = 50;
                shockwaveButton.bottomInPixels = 150;
                shockwaveButton.onPointerDownObservable.add(() => useShockwave(shockwaveButton));
                advancedTexture.addControl(shockwaveButton);

                const optionsButton = BABYLON.GUI.Button.CreateSimpleButton("options", "⚙️");
                optionsButton.widthInPixels = 50;
                optionsButton.heightInPixels = 50;
                optionsButton.color = "white";
                optionsButton.cornerRadius = 25;
                optionsButton.background = "rgba(0, 0, 0, 0.6)";
                optionsButton.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;
                optionsButton.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;
                optionsButton.topInPixels = 10;
                optionsButton.rightInPixels = 10;
                optionsButton.onPointerDownObservable.add(() => {
                    shadowGenerator.isEnabled = !shadowGenerator.isEnabled;
                    postProcess.bloomEnabled = !postProcess.bloomEnabled;
                });
                advancedTexture.addControl(optionsButton);
            }

            let headbobTime = 0;
            let lastCameraRotation = camera.rotation.clone();
            scene.onBeforeRenderObservable.add(() => {
                if (gameState !== 'playing') return;

                if (playerState.isFiring) {
                    playerShoot();
                }

                const isMoving = camera.velocity.length() > 0.1;
                if(isMoving) {
                    hudElements.crosshair.classList.add('moving');
                    headbobTime += engine.getDeltaTime() / 1000;
                    const bobAmount = Math.sin(headbobTime * 8) * 0.03;
                    weapon.position.y = -0.45 + bobAmount;

                    const currentTime = performance.now();
                    if(currentTime - lastStepTime > 400){
                        sounds.footstep.play();
                        lastStepTime = currentTime;
                    }
                } else {
                    hudElements.crosshair.classList.remove('moving');
                    headbobTime = 0;
                }

                const rotationDelta = camera.rotation.subtract(lastCameraRotation);
                weapon.position.x = BABYLON.Scalar.Lerp(weapon.position.x, 0.3 - rotationDelta.y * 0.2, 0.1);
                weapon.position.y = BABYLON.Scalar.Lerp(weapon.position.y, -0.45 - rotationDelta.x * 0.2, 0.1);
                lastCameraRotation = camera.rotation.clone();

                const currentTime = performance.now() / 1000;
                for (let i = enemies.length - 1; i >= 0; i--) {
                    const enemy = enemies[i];
                    if (!enemy.isAlive || enemy.mesh.isDisposed()) {
                        continue;
                    }
                    const distanceToPlayer = BABYLON.Vector3.Distance(enemy.mesh.position, camera.position);
                    enemy.state = (distanceToPlayer < 35) ? 'attack' : 'patrol';

                    if (enemy.state === 'attack') {
                        enemy.mesh.lookAt(camera.position);

                        if (enemy.type === 'brute' && distanceToPlayer < 10) {
                            const chargeVector = enemy.mesh.forward.scale(enemy.patrolSpeed * 5);
                            enemy.mesh.position.addInPlace(chargeVector);
                        } else if (distanceToPlayer < 5) {
                            const moveBack = enemy.mesh.forward.scale(-enemy.patrolSpeed * 1.5);
                            enemy.mesh.position.addInPlace(moveBack);
                        }

                        if (enemy.type === 'scout') {
                            enemy.strafeTime -= engine.getDeltaTime() / 1000;
                            if (enemy.strafeTime <= 0) {
                                enemy.strafeDirection *= -1;
                                enemy.strafeTime = Math.random() * 2 + 1;
                            }
                            const strafeVector = enemy.mesh.right.scale(enemy.strafeDirection * 0.05);
                            enemy.mesh.position.addInPlace(strafeVector);
                        }

                        if (currentTime - enemy.lastAttackTime > enemy.attackCooldown) {
                            enemyShoot(enemy);
                            enemy.lastAttackTime = currentTime;
                        }
                    } else {
                        enemy.mesh.position.addInPlace(enemy.patrolDirection.scale(enemy.patrolSpeed));
                        if (Math.abs(enemy.mesh.position.x) > 48 || Math.abs(enemy.mesh.position.z) > 48) {
                            enemy.patrolDirection.negateInPlace();
                        }
                    }
                }
            });
            
            function startGame() {
                if (gameState === 'start' || gameState === 'win' || gameState === 'gameover') {
                     hudElements.start.style.display = 'none';
                     hudElements.win.style.display = 'none';
                     hudElements.gameOver.style.display = 'none';
                    initGame();
                    gameState = 'playing';
                }
            }

            hudElements.start.addEventListener('pointerdown', startGame);
            hudElements.win.addEventListener('pointerdown', startGame);
            hudElements.gameOver.addEventListener('pointerdown', startGame);

            createEnvironment();
            createWeapon();
            createMobileUI();
            
            engine.runRenderLoop(() => {
                if(!scene.isDisposed) {
                    scene.render();
                }
            });
            window.addEventListener('resize', () => engine.resize());
        });
    </script>
</body>
</html>
