<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Sobrevivente da Horda 2.0</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overflow: hidden;
            background-color: #111827;
            touch-action: none;
        }
        canvas {
            background-color: #0c101a;
            cursor: none;
            display: block;
            transition: transform 0.1s ease-in-out;
        }
        .hud-element {
            background-color: rgba(17, 24, 39, 0.8);
            border: 1px solid rgba(55, 65, 81, 0.8);
            backdrop-filter: blur(4px);
        }
        .upgrade-card {
            transition: all 0.2s ease-in-out;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }
        .upgrade-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 15px -3px rgba(99, 102, 241, 0.3), 0 4px 6px -2px rgba(99, 102, 241, 0.2);
            border-color: #6366f1;
        }
        #virtual-joystick-base {
            position: absolute;
            width: 120px;
            height: 120px;
            background: rgba(55, 65, 81, 0.4);
            border-radius: 50%;
            display: none; /* Ativado via JS para mobile */
            pointer-events: none;
        }
        #virtual-joystick-handle {
            position: absolute;
            width: 60px;
            height: 60px;
            background: rgba(107, 114, 128, 0.6);
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }
        .animated-bg {
             background-image:
                 linear-gradient(rgba(255, 255, 255, 0.05) 1px, transparent 1px),
                 linear-gradient(90deg, rgba(255, 255, 255, 0.05) 1px, transparent 1px);
            background-size: 40px 40px;
            animation: bg-scroll 10s linear infinite;
        }
        @keyframes bg-scroll {
            from { background-position: 0 0; }
            to { background-position: -40px -40px; }
        }
        .coin-icon {
            display: inline-block;
            width: 1em;
            height: 1em;
            background-color: #facc15;
            border-radius: 50%;
            border: 2px solid #ca8a04;
            text-align: center;
            line-height: 0.9em;
            font-weight: bold;
            color: #ca8a04;
            font-style: normal;
        }
    </style>
</head>
<body class="text-white select-none">

    <div id="game-container" class="relative w-screen h-screen">
        <canvas id="gameCanvas"></canvas>

        <!-- HUD do Jogo -->
        <div id="hud" class="absolute top-0 left-0 w-full p-4 pointer-events-none hidden">
            <div class="flex justify-between items-start">
                <div class="flex flex-col items-start gap-2">
                    <div id="timer" class="hud-element text-lg font-bold px-4 py-2 rounded-lg">Tempo: 00:00</div>
                    <div id="kill-count" class="hud-element text-sm px-3 py-1 rounded-md">Abates: 0</div>
                    <div id="coin-count" class="hud-element text-sm px-3 py-1 rounded-md flex items-center gap-2">
                        <i class="coin-icon">$</i> <span id="coins-collected">0</span>
                    </div>
                </div>
                <div class="flex flex-col items-center gap-2 w-1/3">
                    <div id="level-display" class="hud-element text-lg font-bold px-4 py-2 rounded-lg">N√≠vel: 1</div>
                    <div class="w-full bg-gray-700 rounded-full h-4 border-2 border-gray-600">
                        <div id="xp-bar" class="bg-indigo-500 h-full rounded-full transition-all duration-300" style="width: 0%"></div>
                    </div>
                </div>
                <div id="active-weapons-ui" class="flex flex-col items-end gap-2"></div>
            </div>
            <div id="boss-alert" class="absolute top-1/3 left-1/2 -translate-x-1/2 text-4xl font-bold text-red-500 drop-shadow-lg hidden animate-pulse">CHEFE APARECEU!</div>
        </div>

        <!-- Tela Inicial -->
        <div id="start-screen" class="absolute inset-0 bg-gray-900 bg-opacity-80 flex flex-col justify-center items-center backdrop-blur-sm z-10 animated-bg">
            <h1 class="text-6xl font-bold text-indigo-400 drop-shadow-lg mb-4">Sobrevivente da Horda 2.0</h1>
            <p class="text-xl text-gray-300 mb-8">Mova-se com WASD/Setas/Joystick. Os ataques s√£o autom√°ticos.</p>
            <div class="flex gap-4">
                <button id="start-button" class="bg-indigo-600 hover:bg-indigo-500 text-white font-bold py-4 px-8 rounded-lg text-2xl shadow-lg transition-transform transform hover:scale-105">
                    Iniciar Jogo
                </button>
                <button id="store-button-main" class="bg-yellow-600 hover:bg-yellow-500 text-white font-bold py-4 px-8 rounded-lg text-2xl shadow-lg transition-transform transform hover:scale-105">
                    Loja
                </button>
            </div>
            <div id="total-coins-main" class="mt-8 hud-element text-lg px-4 py-2 rounded-lg flex items-center gap-2">
                Total: <i class="coin-icon">$</i> <span id="total-coins-display-main">0</span>
            </div>
        </div>

        <!-- Tela de Level Up -->
        <div id="level-up-screen" class="absolute inset-0 bg-gray-900 bg-opacity-80 flex-col justify-center items-center backdrop-blur-sm z-20 hidden">
             <h2 id="level-up-title" class="text-4xl font-bold mb-8">N√≠vel Acima!</h2>
            <p class="text-lg mb-8">Escolha uma melhoria:</p>
            <div id="upgrade-options" class="flex flex-wrap justify-center gap-6"></div>
        </div>
        
        <!-- Tela de Pausa -->
        <div id="pause-screen" class="absolute inset-0 bg-gray-900 bg-opacity-80 flex flex-col justify-center items-center backdrop-blur-sm z-30 hidden">
            <h1 class="text-6xl font-bold text-gray-300 mb-8">Pausado</h1>
            <button id="resume-button" class="bg-indigo-600 hover:bg-indigo-500 text-white font-bold py-4 px-8 rounded-lg text-2xl">Continuar</button>
        </div>

        <!-- Loja de Melhorias Permanentes -->
        <div id="store-screen" class="absolute inset-0 bg-gray-900 bg-opacity-90 flex-col justify-center items-center backdrop-blur-md z-40 hidden p-4 overflow-y-auto">
            <h1 class="text-4xl font-bold text-yellow-400 mb-4">Melhorias Permanentes</h1>
            <div class="mb-6 hud-element text-lg px-4 py-2 rounded-lg flex items-center gap-2">
                Moedas: <i class="coin-icon">$</i> <span id="total-coins-display-store">0</span>
            </div>
            <div id="meta-upgrades-container" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4 max-w-4xl w-full"></div>
            <button id="close-store-button" class="mt-8 bg-gray-600 hover:bg-gray-500 text-white font-bold py-3 px-6 rounded-lg text-xl">Voltar</button>
        </div>

        <!-- Tela de Game Over -->
        <div id="game-over-screen" class="absolute inset-0 bg-gray-900 bg-opacity-80 flex flex-col justify-center items-center backdrop-blur-sm z-10 hidden">
            <h1 class="text-7xl font-bold text-red-500 drop-shadow-lg mb-4">Fim de Jogo</h1>
            <div class="text-2xl text-gray-300 mb-8 bg-gray-800 p-6 rounded-lg border border-gray-700 text-center">
                <p>Tempo Sobrevivido: <span id="final-time" class="font-bold text-white"></span></p>
                <p>Inimigos Abatidos: <span id="final-kills" class="font-bold text-white"></span></p>
                <p>N√≠vel Alcan√ßado: <span id="final-level" class="font-bold text-white"></span></p>
                <p>Moedas Coletadas: <span id="final-coins" class="font-bold text-white"></span></p>
            </div>
            <div class="flex gap-4">
                <button id="restart-button" class="bg-indigo-600 hover:bg-indigo-500 text-white font-bold py-4 px-8 rounded-lg text-2xl">Tentar Novamente</button>
                <button id="store-button-gameover" class="bg-yellow-600 hover:bg-yellow-500 text-white font-bold py-4 px-8 rounded-lg text-2xl">Loja</button>
            </div>
        </div>

        <!-- Controles Mobile -->
        <div id="virtual-joystick-base">
            <div id="virtual-joystick-handle"></div>
        </div>
        <button id="pause-button" class="absolute top-4 right-4 bg-gray-700 p-3 rounded-full pointer-events-auto hidden z-10">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="6" y1="4" x2="6" y2="20"></line><line x1="18" y1="4" x2="18" y2="20"></line></svg>
        </button>
    </div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        // --- ELEMENTOS DA UI ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const hud = document.getElementById('hud');
        const startScreen = document.getElementById('start-screen');
        const levelUpScreen = document.getElementById('level-up-screen');
        const gameOverScreen = document.getElementById('game-over-screen');
        const pauseScreen = document.getElementById('pause-screen');
        const storeScreen = document.getElementById('store-screen');
        
        const startButton = document.getElementById('start-button');
        const restartButton = document.getElementById('restart-button');
        const resumeButton = document.getElementById('resume-button');
        const storeButtonMain = document.getElementById('store-button-main');
        const storeButtonGameOver = document.getElementById('store-button-gameover');
        const closeStoreButton = document.getElementById('close-store-button');
        const pauseButton = document.getElementById('pause-button');
        
        const upgradeOptionsContainer = document.getElementById('upgrade-options');
        const metaUpgradesContainer = document.getElementById('meta-upgrades-container');

        // Displays do HUD
        const timerDisplay = document.getElementById('timer');
        const killCountDisplay = document.getElementById('kill-count');
        const coinsCollectedDisplay = document.getElementById('coins-collected');
        const levelDisplay = document.getElementById('level-display');
        const xpBar = document.getElementById('xp-bar');
        const activeWeaponsUI = document.getElementById('active-weapons-ui');
        const bossAlert = document.getElementById('boss-alert');
        
        // Displays de Fim de Jogo
        const finalTime = document.getElementById('final-time');
        const finalKills = document.getElementById('final-kills');
        const finalLevel = document.getElementById('final-level');
        const finalCoins = document.getElementById('final-coins');
        const totalCoinsDisplayMain = document.getElementById('total-coins-display-main');
        const totalCoinsDisplayStore = document.getElementById('total-coins-display-store');

        // Joystick
        const joystickBase = document.getElementById('virtual-joystick-base');
        const joystickHandle = document.getElementById('virtual-joystick-handle');

        // --- VARI√ÅVEIS DE ESTADO DO JOGO ---
        let gameRunning = false;
        let paused = false;
        let gameTime = 0;
        let lastTime = 0;
        let animationFrameId;

        let player, camera, worldBounds, keys = {};
        let enemies = [], projectiles = [], xpGems = [], items = [], particles = [], damageNumbers = [], coins = [];
        
        let bossSpawned = false;
        let screenShake = { duration: 0, magnitude: 0, active: false };
        let isMobile = false;

        // --- CONFIGURA√á√ïES ---
        const XP_PER_LEVEL = [0, 10, 25, 45, 70, 100, 140, 190, 250, 320, 400]; // E mais al√©m

        // --- METAPROGRESS√ÉO ---
        let totalCoins = 0;
        let metaUpgrades = {};
        
        const metaUpgradesList = {
            maxHp: { name: "Vitalidade", description: "+10% Vida M√°xima", baseCost: 50, level: 0, maxLevel: 20 },
            damage: { name: "For√ßa", description: "+5% Dano", baseCost: 75, level: 0, maxLevel: 10 },
            speed: { name: "Agilidade", description: "+2% Velocidade Mov.", baseCost: 60, level: 0, maxLevel: 10 },
            greed: { name: "Gan√¢ncia", description: "+10% Moedas", baseCost: 100, level: 0, maxLevel: 10 },
        };
        
        // --- L√ìGICA DE √ÅUDIO ---
        let audioContext;
        const sounds = {};
        function initAudio() {
            if (audioContext) return;
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                sounds.xp = () => playSound(880, 'triangle', 0.05, 0.1);
                sounds.hit = () => playSound(100, 'square', 0.1, 0.3);
                sounds.shoot = () => playSound(440, 'triangle', 0.08, 0.2);
                sounds.levelUp = () => { playSound(261.63, 'sine', 0.1, 0.5, 0); playSound(329.63, 'sine', 0.1, 0.5, 0.1); playSound(392.00, 'sine', 0.1, 0.5, 0.2); };
                sounds.playerHit = () => { playSound(150, 'sawtooth', 0.2, 0.5); triggerScreenShake(0.2, 5); }
                sounds.enemyDeath = () => playSound(200, 'square', 0.1, 0.2);
                sounds.coin = () => playSound(1046.50, 'sine', 0.05, 0.2);
            } catch(e) { console.error("Web Audio API is not supported in this browser"); }
        }
        function playSound(freq, type, duration, gain = 1, delay = 0) {
            if (!audioContext) return;
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            oscillator.type = type;
            oscillator.frequency.setValueAtTime(freq, audioContext.currentTime + delay);
            gainNode.gain.setValueAtTime(gain, audioContext.currentTime + delay);
            gainNode.gain.exponentialRampToValueAtTime(0.0001, audioContext.currentTime + delay + duration);
            oscillator.start(audioContext.currentTime + delay);
            oscillator.stop(audioContext.currentTime + delay + duration);
        }

        // --- L√ìGICA DO JOYSTICK VIRTUAL ---
        let joystick = { active: false, x: 0, y: 0, dx: 0, dy: 0, radius: 60 };
        function setupJoystick() {
            if (!isMobile) return;
            joystickBase.style.display = 'block';
            pauseButton.classList.remove('hidden');

            canvas.addEventListener('touchstart', e => {
                if (!gameRunning || paused) return;
                const touch = e.touches[0];
                if (touch.clientX < window.innerWidth / 2) { // Ativar s√≥ no lado esquerdo
                    joystick.active = true;
                    joystick.x = touch.clientX;
                    joystick.y = touch.clientY;
                    joystickBase.style.left = `${joystick.x - joystick.radius}px`;
                    joystickBase.style.top = `${joystick.y - joystick.radius}px`;
                }
            }, { passive: false });

            canvas.addEventListener('touchmove', e => {
                if (!joystick.active) return;
                e.preventDefault();
                const touch = e.touches[0];
                const deltaX = touch.clientX - joystick.x;
                const deltaY = touch.clientY - joystick.y;
                const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                const angle = Math.atan2(deltaY, deltaX);
                
                const cappedDist = Math.min(distance, joystick.radius / 2);
                joystickHandle.style.transform = `translate(-50%, -50%) translate(${Math.cos(angle) * cappedDist}px, ${Math.sin(angle) * cappedDist}px)`;
                
                joystick.dx = deltaX / (joystick.radius / 2);
                joystick.dy = deltaY / (joystick.radius / 2);
                const mag = Math.sqrt(joystick.dx**2 + joystick.dy**2);
                if (mag > 1) {
                    joystick.dx /= mag;
                    joystick.dy /= mag;
                }
            }, { passive: false });

            canvas.addEventListener('touchend', e => {
                if (!joystick.active) return;
                // Verificar se o toque que terminou foi o do joystick
                let touchEndedOnJoystickSide = true;
                for (let touch of e.changedTouches) {
                    if (touch.clientX >= window.innerWidth / 2) {
                        touchEndedOnJoystickSide = false;
                    }
                }

                if (touchEndedOnJoystickSide) {
                     joystick.active = false;
                     joystick.dx = 0;
                     joystick.dy = 0;
                     joystickBase.style.left = '-1000px'; // Esconder fora da tela
                     joystickHandle.style.transform = 'translate(-50%, -50%)';
                }
            });
        }
        
        // --- CLASSES DO JOGO ---
        class Player {
            constructor() { this.reset(); }
            reset() {
                this.x = worldBounds.width / 2;
                this.y = worldBounds.height / 2;
                this.radius = 15;
                this.color = '#818cf8';
                
                this.baseMaxHp = 100;
                this.baseSpeed = 200;
                this.baseDamage = 1;
                this.baseGreed = 1;

                this.maxHp = this.baseMaxHp * (1 + (metaUpgrades.maxHp?.level || 0) * 0.1);
                this.hp = this.maxHp;
                this.speed = this.baseSpeed * (1 + (metaUpgrades.speed?.level || 0) * 0.02);
                
                this.xp = 0;
                this.level = 1;
                this.killCount = 0;
                this.coins = 0;
                this.magnetRadius = 80;
                this.weapons = [];
                this.upgrades = { 
                    damage: 1 * (1 + (metaUpgrades.damage?.level || 0) * 0.05),
                    cooldown: 1, 
                    area: 1, 
                    projectiles: 0,
                    greed: 1 * (1 + (metaUpgrades.greed?.level || 0) * 0.1),
                    duration: 1,
                    speed: 1, // Projectile speed
                };
                this.lastHitTime = 0;
                this.addWeapon(new MagicMissile());
            }

            update(dt) {
                // Movimento
                let dx = 0, dy = 0;
                if (isMobile && joystick.active) {
                    dx = joystick.dx;
                    dy = joystick.dy;
                } else {
                    if (keys['w'] || keys['ArrowUp']) dy -= 1;
                    if (keys['s'] || keys['ArrowDown']) dy += 1;
                    if (keys['a'] || keys['ArrowLeft']) dx -= 1;
                    if (keys['d'] || keys['ArrowRight']) dx += 1;
                }
                
                const magnitude = Math.sqrt(dx * dx + dy * dy);
                if (magnitude > 0) {
                    dx /= magnitude;
                    dy /= magnitude;
                    this.x += dx * this.speed * dt;
                    this.y += dy * this.speed * dt;
                }

                // Manter dentro do mundo
                this.x = Math.max(this.radius, Math.min(this.x, worldBounds.width - this.radius));
                this.y = Math.max(this.radius, Math.min(this.y, worldBounds.height - this.radius));

                // Atualizar armas
                this.weapons.forEach(w => w.update(dt, this));
            }

            draw(ctx) {
                // Desenhar o jogador
                ctx.fillStyle = this.color;
                 if (gameTime < this.lastHitTime + 0.2) {
                    ctx.fillStyle = 'white'; // Flash on hit
                }
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();

                // Barra de vida
                ctx.fillStyle = 'red';
                ctx.fillRect(this.x - this.radius, this.y + this.radius + 5, this.radius * 2, 5);
                ctx.fillStyle = 'green';
                ctx.fillRect(this.x - this.radius, this.y + this.radius + 5, (this.radius * 2) * (this.hp / this.maxHp), 5);
            }

            takeDamage(amount) {
                this.hp -= amount;
                this.lastHitTime = gameTime;
                sounds.playerHit();
                if (this.hp <= 0) {
                    gameOver();
                }
            }
            
            addXp(amount) {
                this.xp += amount;
                const xpNeeded = getXpForLevel(this.level + 1);
                if (this.xp >= xpNeeded) {
                    this.level++;
                    this.xp -= xpNeeded;
                    sounds.levelUp();
                    triggerLevelUp();
                }
                updateHUD();
            }

            addWeapon(weapon) {
                this.weapons.push(weapon);
                updateActiveWeaponsUI();
            }
        }
        
        class Camera {
            constructor() {
                this.x = 0;
                this.y = 0;
                this.width = canvas.width;
                this.height = canvas.height;
            }
            update(player) {
                this.x = player.x - this.width / 2;
                this.y = player.y - this.height / 2;

                // Manter a c√¢mera dentro do mundo
                this.x = Math.max(0, Math.min(this.x, worldBounds.width - this.width));
                this.y = Math.max(0, Math.min(this.y, worldBounds.height - this.height));
            }
            apply(ctx) {
                ctx.save();
                let tx = -this.x;
                let ty = -this.y;

                if (screenShake.active && screenShake.duration > 0) {
                    tx += (Math.random() - 0.5) * screenShake.magnitude * 2;
                    ty += (Math.random() - 0.5) * screenShake.magnitude * 2;
                }
                ctx.translate(tx, ty);
            }
            release(ctx) {
                ctx.restore();
            }
        }

        // --- Inimigos ---
        class Enemy {
            constructor(x,y){ this.x=x; this.y=y; this.lastHitTime = 0; }
            update(dt, player) {
                const angle = Math.atan2(player.y - this.y, player.x - this.x);
                this.x += Math.cos(angle) * this.speed * dt;
                this.y += Math.sin(angle) * this.speed * dt;
            }
            draw(ctx) {
                 if (gameTime < this.lastHitTime + 0.1) {
                    ctx.fillStyle = 'white';
                } else {
                    ctx.fillStyle = this.color;
                }
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
            }
            takeDamage(amount) {
                this.hp -= amount;
                this.lastHitTime = gameTime;
                sounds.hit();
                damageNumbers.push(new DamageNumber(this.x, this.y, amount));
                if (this.hp <= 0) {
                    this.onDeath();
                    return true;
                }
                return false;
            }
            onDeath() {
                player.killCount++;
                sounds.enemyDeath();
                xpGems.push(new XpGem(this.x, this.y, this.xpValue));
                // Chance de dropar moeda
                if (Math.random() < 0.2) {
                    coins.push(new Coin(this.x, this.y, 1));
                }
                for(let i = 0; i < 5; i++) {
                     particles.push(new Particle(this.x, this.y, this.color));
                }
            }
        }
        class Slime extends Enemy {
            constructor(x, y) {
                super(x, y);
                this.radius = 12;
                this.color = '#4ade80';
                this.speed = 80 + gameTime / 10;
                this.hp = 10 + gameTime / 5;
                this.damage = 5;
                this.xpValue = 2;
            }
        }
        class Bat extends Enemy {
             constructor(x, y) {
                super(x, y);
                this.radius = 10;
                this.color = '#f87171';
                this.speed = 120 + gameTime / 8;
                this.hp = 7 + gameTime / 6;
                this.damage = 8;
                this.xpValue = 3;
            }
        }
        class Tank extends Enemy {
             constructor(x, y) {
                super(x, y);
                this.radius = 20;
                this.color = '#60a5fa';
                this.speed = 50 + gameTime / 15;
                this.hp = 50 + gameTime / 2;
                this.damage = 20;
                this.xpValue = 10;
            }
        }
        class Boss extends Enemy {
             constructor(x, y) {
                super(x, y);
                this.radius = 50;
                this.color = '#f43f5e';
                this.speed = 60;
                this.hp = 2000;
                this.damage = 40;
                this.xpValue = 200;
            }
             onDeath() { // Sobrescreve onDeath para dropar um ba√∫
                player.killCount++;
                sounds.enemyDeath();
                // Ba√∫ dropa 3 upgrades
                items.push(new Chest(this.x, this.y));
                for(let i = 0; i < 50; i++) {
                     particles.push(new Particle(this.x, this.y, this.color, 3));
                }
            }
        }

        // --- Outros Objetos ---
        class Projectile {
            constructor(x,y,vx,vy,damage,radius,color,lifespan){ 
                this.x=x; this.y=y; this.vx=vx; this.vy=vy; 
                this.damage = damage;
                this.radius=radius; this.color=color;
                this.lifespan = lifespan;
                this.life = 0;
            }
            update(dt) {
                this.x += this.vx * dt;
                this.y += this.vy * dt;
                this.life += dt;
            }
            draw(ctx) {
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        class Collectible {
            constructor(x, y, radius) {
                this.x = x; this.y = y; this.radius = radius;
            }
            update(dt, target) {
                const dist = Math.hypot(target.x - this.x, target.y - this.y);
                if (dist < target.magnetRadius) {
                    const angle = Math.atan2(target.y - this.y, target.x - this.x);
                    this.x += Math.cos(angle) * 300 * dt;
                    this.y += Math.sin(angle) * 300 * dt;
                }
            }
        }
        class XpGem extends Collectible {
            constructor(x,y,value) { 
                super(x, y, 5);
                this.value = value;
                this.color = '#a78bfa';
            }
            draw(ctx){ 
                ctx.fillStyle=this.color;
                ctx.beginPath();
                ctx.moveTo(this.x, this.y - this.radius);
                for (let i = 1; i < 5; i++) {
                    const angle = i * 2 * Math.PI / 5;
                    const innerAngle = angle + Math.PI / 5;
                    ctx.lineTo(this.x + Math.sin(angle) * this.radius, this.y - Math.cos(angle) * this.radius);
                }
                ctx.closePath();
                ctx.fill();
            }
        }
        class Coin extends Collectible {
            constructor(x,y,value){ 
                super(x, y, 6);
                this.value=value; 
            }
            draw(ctx){ 
                ctx.fillStyle='#facc15'; 
                ctx.strokeStyle = '#ca8a04';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
            }
        }
        class Chest {
            constructor(x,y){ this.x=x; this.y=y; this.radius=20; }
            draw(ctx) {
                ctx.fillStyle = '#a16207'; // Marrom
                ctx.fillRect(this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2);
                ctx.fillStyle = '#facc15'; // Amarelo
                ctx.fillRect(this.x - this.radius, this.y - 8, this.radius * 2, 4); // Fechadura
            }
        }

        class Particle {
            constructor(x, y, color, size = 1) {
                this.x = x; this.y = y; this.color = color;
                this.size = Math.random() * 2 * size + 1 * size;
                this.life = 1;
                this.vx = (Math.random() - 0.5) * 100;
                this.vy = (Math.random() - 0.5) * 100;
            }
            update(dt) {
                this.x += this.vx * dt;
                this.y += this.vy * dt;
                this.life -= dt;
            }
            draw(ctx) {
                ctx.globalAlpha = this.life;
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x - this.size / 2, this.y - this.size / 2, this.size, this.size);
                ctx.globalAlpha = 1;
            }
        }
        class DamageNumber {
            constructor(x, y, amount) {
                this.x = x; this.y = y;
                this.amount = Math.round(amount);
                this.life = 1;
                this.vy = -50;
            }
            update(dt) {
                this.y += this.vy * dt;
                this.life -= dt;
            }
            draw(ctx) {
                ctx.globalAlpha = this.life;
                ctx.fillStyle = 'white';
                ctx.font = 'bold 16px Inter';
                ctx.fillText(this.amount, this.x, this.y);
                ctx.globalAlpha = 1;
            }
        }


        // --- Sistema de Armas e Upgrades ---
        const allUpgrades = {};

        class Weapon {
            constructor(name, description, icon) {
                this.name = name;
                this.description = description;
                this.icon = icon;
                this.level = 1;
                this.cooldownTimer = 0;
            }
            
            getBaseUpgradeOptions() {
                return [
                    { type: 'stat', stat: 'damage', value: 0.15, name: `+15% Dano (${this.name})` },
                    { type: 'stat', stat: 'cooldown', value: -0.1, name: `-10% Recarga (${this.name})` },
                ];
            }

            getUpgradeOptions() {
                // Implementado por subclasses
                return this.getBaseUpgradeOptions();
            }

            applyUpgrade(upgrade) {
                // Implementado por subclasses
            }
        }

        class MagicMissile extends Weapon {
            constructor() {
                super("M√≠ssil M√°gico", "Dispara um proj√©til no inimigo mais pr√≥ximo.", "üîÆ");
                this.baseCooldown = 2;
                this.baseDamage = 10;
                this.numProjectiles = 1;
            }
            update(dt, player) {
                this.cooldownTimer -= dt;
                if (this.cooldownTimer <= 0) {
                    this.cooldownTimer = this.baseCooldown * player.upgrades.cooldown;
                    const target = findClosestEnemy(player);
                    if (target) {
                        for(let i = 0; i < this.numProjectiles; i++){
                            setTimeout(() => {
                                const angle = Math.atan2(target.y - player.y, target.x - player.x);
                                const speed = 300 * player.upgrades.speed;
                                const damage = this.baseDamage * player.upgrades.damage;
                                projectiles.push(new Projectile(player.x, player.y, Math.cos(angle) * speed, Math.sin(angle) * speed, damage, 5, '#bae6fd', 3));
                                sounds.shoot();
                            }, i * 100); // Pequeno delay entre proj√©teis
                        }
                    }
                }
            }
            getUpgradeOptions() {
                 const options = this.getBaseUpgradeOptions();
                 options.push({ type: 'weapon', weapon: this, key: 'numProjectiles', value: 1, name: `+1 M√≠ssil (${this.name})`});
                 return options;
            }
            applyUpgrade(upgrade) {
                if(upgrade.key === 'numProjectiles') this.numProjectiles += upgrade.value;
                if(upgrade.stat === 'damage') this.baseDamage *= (1 + upgrade.value);
                if(upgrade.stat === 'cooldown') this.baseCooldown *= (1 + upgrade.value);
            }
        }
        
        class SpinningSickle extends Weapon {
             constructor() {
                super("Foice Girat√≥ria", "Foices orbitam o jogador, causando dano.", "üî™");
                this.baseDamage = 5;
                this.numSickles = 2;
                this.orbitRadius = 60;
                this.rotationSpeed = 2;
                this.angle = 0;
                this.sickles = []; // {angle, radius}
                this.lastHitEnemies = new Map();
            }
            update(dt, player) {
                this.angle += this.rotationSpeed * dt;
                
                // Limpar inimigos atingidos
                this.lastHitEnemies.forEach((time, enemy) => {
                    if (gameTime - time > 0.5) { // S√≥ pode atingir o mesmo inimigo a cada 0.5s
                        this.lastHitEnemies.delete(enemy);
                    }
                });

                enemies.forEach(enemy => {
                    for (let i = 0; i < this.numSickles; i++) {
                        const currentAngle = this.angle + (i * 2 * Math.PI / this.numSickles);
                        const sickleX = player.x + Math.cos(currentAngle) * this.orbitRadius * player.upgrades.area;
                        const sickleY = player.y + Math.sin(currentAngle) * this.orbitRadius * player.upgrades.area;
                        const dist = Math.hypot(enemy.x - sickleX, enemy.y - sickleY);

                        if (dist < enemy.radius + 10 && !this.lastHitEnemies.has(enemy)) {
                             enemy.takeDamage(this.baseDamage * player.upgrades.damage * dt * 5); // Dano por segundo
                             this.lastHitEnemies.set(enemy, gameTime);
                        }
                    }
                });
            }
            draw(ctx, player) {
                 for (let i = 0; i < this.numSickles; i++) {
                    const currentAngle = this.angle + (i * 2 * Math.PI / this.numSickles);
                    const sickleX = player.x + Math.cos(currentAngle) * this.orbitRadius * player.upgrades.area;
                    const sickleY = player.y + Math.sin(currentAngle) * this.orbitRadius * player.upgrades.area;
                    
                    ctx.save();
                    ctx.translate(sickleX, sickleY);
                    ctx.rotate(this.angle * 2);
                    ctx.fillStyle = '#9ca3af';
                    ctx.font = '20px sans-serif';
                    ctx.fillText(this.icon, -10, 10);
                    ctx.restore();
                }
            }
             getUpgradeOptions() {
                 const options = this.getBaseUpgradeOptions();
                 options.push({ type: 'weapon', weapon: this, key: 'numSickles', value: 1, name: `+1 Foice (${this.name})`});
                 options.push({ type: 'weapon', weapon: this, key: 'rotationSpeed', value: 0.5, name: `+25% Vel. Rota√ß√£o (${this.name})`});
                 return options;
            }
            applyUpgrade(upgrade) {
                if(upgrade.key === 'numSickles') this.numSickles += upgrade.value;
                if(upgrade.key === 'rotationSpeed') this.rotationSpeed += upgrade.value;
                if(upgrade.stat === 'damage') this.baseDamage *= (1 + upgrade.value);
            }
        }
        
        class GarlicAura extends Weapon {
            constructor() {
                super("Aura de Alho", "Causa dano cont√≠nuo a inimigos pr√≥ximos.", "üßÑ");
                this.baseDamage = 2; // DPS
                this.radius = 80;
                this.cooldownTimer = 0;
            }
            update(dt, player) {
                this.cooldownTimer -= dt;
                if(this.cooldownTimer <= 0) {
                    this.cooldownTimer = 0.2; // Aplica dano 5x por segundo
                     enemies.forEach(enemy => {
                        const dist = Math.hypot(enemy.x - player.x, enemy.y - player.y);
                        if(dist < this.radius * player.upgrades.area + enemy.radius) {
                             enemy.takeDamage(this.baseDamage * player.upgrades.damage * 0.2);
                        }
                    });
                }
            }
             draw(ctx, player) {
                ctx.beginPath();
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
                ctx.arc(player.x, player.y, this.radius * player.upgrades.area, 0, Math.PI * 2);
                ctx.stroke();
            }
             getUpgradeOptions() {
                 const options = this.getBaseUpgradeOptions();
                 options.push({ type: 'stat', stat: 'area', value: 0.2, name: `+20% √Årea (${this.name})`});
                 return options;
            }
            applyUpgrade(upgrade) {
                if(upgrade.stat === 'damage') this.baseDamage *= (1 + upgrade.value);
            }
        }
        
        const possibleWeapons = [SpinningSickle, GarlicAura];

        // --- FUN√á√ïES DE CONTROLE DO JOGO ---
        function init() {
            isMobile = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
            loadMetaProgress();
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            
            // Controles teclado
            window.addEventListener('keydown', (e) => { 
                keys[e.key.toLowerCase()] = true; 
                if (e.key === 'Escape' && gameRunning) togglePause();
            });
            window.addEventListener('keyup', (e) => { keys[e.key.toLowerCase()] = false; });

            // Controles bot√µes
            startButton.addEventListener('click', startGame);
            restartButton.addEventListener('click', startGame);
            resumeButton.addEventListener('click', togglePause);
            storeButtonMain.addEventListener('click', () => showStore(true));
            storeButtonGameOver.addEventListener('click', () => showStore(false));
            closeStoreButton.addEventListener('click', hideStore);
            pauseButton.addEventListener('click', togglePause);
            
            setupJoystick();
        }

        function startGame() {
            if (audioContext && audioContext.state === 'suspended') {
                 audioContext.resume();
            } else {
                 initAudio(); 
            }
            resetGame();
            gameRunning = true;
            paused = false;
            startScreen.classList.add('hidden');
            gameOverScreen.classList.add('hidden');
            hud.classList.remove('hidden');
            lastTime = performance.now();
            gameLoop(lastTime);
        }

        function resetGame() {
             worldBounds = { width: 3000, height: 3000 };
             player = new Player();
             camera = new Camera();
             enemies = []; projectiles = []; xpGems = []; items = []; particles = []; damageNumbers = []; coins = [];
             gameTime = 0;
             lastTime = 0;
             bossSpawned = false;
             updateHUD();
        }
        
        function gameOver() {
            gameRunning = false;
            cancelAnimationFrame(animationFrameId);
            totalCoins += player.coins;
            saveMetaProgress();
            updateCoinDisplays();
            hud.classList.add('hidden');
            gameOverScreen.classList.remove('hidden');
            finalTime.textContent = formatTime(gameTime);
            finalKills.textContent = player.killCount;
            finalLevel.textContent = player.level;
            finalCoins.textContent = player.coins;
        }

        function togglePause() {
            if (!gameRunning) return;
            paused = !paused;
            pauseScreen.classList.toggle('hidden');
            if (!paused) {
                lastTime = performance.now();
                gameLoop(lastTime);
            }
        }

        function triggerLevelUp(isChest = false, choices = 3) {
            paused = true;
            levelUpScreen.classList.remove('hidden');
            upgradeOptionsContainer.innerHTML = '';
            document.getElementById('level-up-title').textContent = isChest ? "Tesouro Encontrado!" : "N√≠vel Acima!";
            
            const availableUpgrades = getAvailableUpgrades();
            const chosenUpgrades = [];

            // Adiciona upgrades para o jogador escolher
            for(let i = 0; i < choices; i++) {
                if(availableUpgrades.length === 0) break;
                const randIndex = Math.floor(Math.random() * availableUpgrades.length);
                chosenUpgrades.push(availableUpgrades[randIndex]);
                availableUpgrades.splice(randIndex, 1);
            }
            
            chosenUpgrades.forEach(upgrade => {
                const card = document.createElement('div');
                card.className = 'upgrade-card bg-gray-800 p-4 rounded-lg border-2 border-gray-700 w-64 text-center cursor-pointer';
                card.innerHTML = `<h3 class="text-xl font-bold text-indigo-400">${upgrade.name}</h3>`;
                card.onclick = () => selectUpgrade(upgrade);
                upgradeOptionsContainer.appendChild(card);
            });

             // Se n√£o houver mais upgrades, oferece moedas
             if (chosenUpgrades.length === 0) {
                 const coinOption = { type: 'coins', value: 50 * player.level, name: `Coletar ${50 * player.level} moedas`};
                 const card = document.createElement('div');
                card.className = 'upgrade-card bg-gray-800 p-4 rounded-lg border-2 border-gray-700 w-64 text-center cursor-pointer';
                card.innerHTML = `<h3 class="text-xl font-bold text-yellow-400">${coinOption.name}</h3>`;
                card.onclick = () => selectUpgrade(coinOption);
                upgradeOptionsContainer.appendChild(card);
             }
        }
        
        function getAvailableUpgrades() {
            const upgrades = [];
            // Upgrades de armas existentes
            player.weapons.forEach(w => {
                w.getUpgradeOptions().forEach(opt => {
                     upgrades.push({ ...opt, name: `${w.icon} ${opt.name}` });
                });
            });

            // Adicionar nova arma
            if (player.weapons.length < 6) {
                const newWeaponOptions = possibleWeapons.filter(wClass => !player.weapons.some(w => w instanceof wClass));
                 newWeaponOptions.forEach(wClass => {
                    const tempWeapon = new wClass();
                    upgrades.push({ type: 'new_weapon', weaponClass: wClass, name: `${tempWeapon.icon} ${tempWeapon.name}`, description: tempWeapon.description });
                });
            }

            // Upgrades globais
            upgrades.push({type: 'stat', stat: 'maxHp', value: 0.2, name: '‚ù§Ô∏è +20% Vida M√°xima'});
            upgrades.push({type: 'stat', stat: 'speed', value: 0.1, name: 'üëü +10% Velocidade Mov.'});
            upgrades.push({type: 'stat', stat: 'magnetRadius', value: 20, name: 'üß≤ +25% √Årea de Coleta'});
            upgrades.push({type: 'stat', stat: 'greed', value: 0.1, name: 'üí∞ +10% Ganho de Moedas'});
            return upgrades;
        }

        function selectUpgrade(upgrade) {
            if (upgrade.type === 'new_weapon') {
                player.addWeapon(new upgrade.weaponClass());
            } else if (upgrade.type === 'weapon') {
                upgrade.weapon.applyUpgrade(upgrade);
                upgrade.weapon.level++;
            } else if (upgrade.type === 'stat') {
                 if(upgrade.stat === 'maxHp') {
                    player.maxHp *= (1 + upgrade.value);
                    player.hp += player.maxHp * upgrade.value; // Cura um pouco
                } else if (upgrade.stat === 'speed'){
                    player.speed *= (1 + upgrade.value);
                } else {
                    player[upgrade.stat] += upgrade.value;
                }
            } else if (upgrade.type === 'coins') {
                 player.coins += upgrade.value;
                 sounds.coin();
            }

            updateActiveWeaponsUI();
            levelUpScreen.classList.add('hidden');
            paused = false;
            lastTime = performance.now();
            gameLoop(lastTime);
        }

        // --- L√ìGICA DE SPAWN ---
        let spawnTimer = 0;
        function handleSpawning(dt) {
            spawnTimer -= dt;
            if (spawnTimer <= 0) {
                 const wave = getWave(gameTime);
                 spawnTimer = wave.interval;
                 for (let i = 0; i < wave.count; i++) {
                     spawnEnemy(wave.types);
                 }
            }
        }
        function getWave(time) {
            if (time < 30) return { count: 3, types: [Slime], interval: 2 };
            if (time < 60) return { count: 5, types: [Slime], interval: 1.8 };
            if (time < 120) return { count: 6, types: [Slime, Bat], interval: 1.5 };
            if (time < 180) return { count: 8, types: [Slime, Bat, Tank], interval: 1.2 };
            if (time < 300) return { count: 10, types: [Bat, Tank], interval: 1 };
            return { count: 15, types: [Slime, Bat, Tank], interval: 0.8 };
        }
        function spawnEnemy(types) {
            const angle = Math.random() * Math.PI * 2;
            const radius = Math.max(canvas.width, canvas.height) / 2 + 100;
            const x = player.x + Math.cos(angle) * radius;
            const y = player.y + Math.sin(angle) * radius;
            const EnemyType = types[Math.floor(Math.random() * types.length)];
            enemies.push(new EnemyType(x, y));
        }
        function spawnBoss() {
            const angle = Math.random() * Math.PI * 2;
            const radius = Math.max(canvas.width, canvas.height) / 2 + 100;
            const x = player.x + Math.cos(angle) * radius;
            const y = player.y + Math.sin(angle) * radius;
            enemies.push(new Boss(x, y));
        }

        // --- ATUALIZA√á√ïES E RENDERIZA√á√ÉO ---
        function update(dt) {
            player.update(dt);
            
            enemies.forEach(e => e.update(dt, player));
            projectiles.forEach(p => p.update(dt));
            xpGems.forEach(g => g.update(dt, player));
            coins.forEach(c => c.update(dt, player));
            particles.forEach(p => p.update(dt));
            damageNumbers.forEach(d => d.update(dt));

            // Colis√µes
            handleCollisions();
            
            // Remo√ß√£o de objetos "mortos"
            projectiles = projectiles.filter(p => p.life < p.lifespan);
            particles = particles.filter(p => p.life > 0);
            damageNumbers = damageNumbers.filter(d => d.life > 0);

            handleSpawning(dt);
            camera.update(player);
            
            if (screenShake.duration > 0) {
                 screenShake.duration -= dt;
            } else if (screenShake.active) {
                screenShake.active = false;
            }
        }
        
        function handleCollisions() {
            // Proj√©teis vs Inimigos
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const p = projectiles[i];
                for (let j = enemies.length - 1; j >= 0; j--) {
                    const e = enemies[j];
                    if (Math.hypot(p.x - e.x, p.y - e.y) < p.radius + e.radius) {
                        if(e.takeDamage(p.damage)) {
                           enemies.splice(j, 1);
                        }
                        projectiles.splice(i, 1);
                        break; 
                    }
                }
            }

            // Jogador vs Inimigos (dano de contato)
            for (let i = enemies.length - 1; i >= 0; i--) {
                const e = enemies[i];
                if (Math.hypot(player.x - e.x, player.y - e.y) < player.radius + e.radius) {
                    player.takeDamage(e.damage);
                }
            }

            // Jogador vs Colet√°veis
            for (let i = xpGems.length - 1; i >= 0; i--) {
                const g = xpGems[i];
                if (Math.hypot(player.x - g.x, player.y - g.y) < player.radius + g.radius) {
                    player.addXp(g.value);
                    xpGems.splice(i, 1);
                    sounds.xp();
                }
            }
            for (let i = coins.length - 1; i >= 0; i--) {
                const c = coins[i];
                if (Math.hypot(player.x - c.x, player.y - c.y) < player.radius + c.radius) {
                    player.coins += c.value * player.upgrades.greed;
                    coins.splice(i, 1);
                    sounds.coin();
                }
            }
            for (let i = items.length - 1; i >= 0; i--) {
                 const item = items[i];
                 if (item instanceof Chest && Math.hypot(player.x - item.x, player.y - item.y) < player.radius + item.radius) {
                     triggerLevelUp(true, 3); // Abre o ba√∫ com 3 op√ß√µes
                     items.splice(i, 1);
                 }
            }
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            camera.apply(ctx);

            // Desenhar fundo (grid)
            drawBackgroundGrid();

            // Desenhar objetos do jogo
            xpGems.forEach(g => g.draw(ctx));
            coins.forEach(c => c.draw(ctx));
            items.forEach(i => i.draw(ctx));
            enemies.forEach(e => e.draw(ctx));
            projectiles.forEach(p => p.draw(ctx));

            player.draw(ctx);
            player.weapons.forEach(w => w.draw && w.draw(ctx, player));

            particles.forEach(p => p.draw(ctx));
            damageNumbers.forEach(d => d.draw(ctx));
            
            camera.release(ctx);
        }

        function drawBackgroundGrid() {
            const gridSize = 50;
            const startX = Math.floor(camera.x / gridSize) * gridSize;
            const startY = Math.floor(camera.y / gridSize) * gridSize;
            ctx.strokeStyle = "rgba(255, 255, 255, 0.05)";
            ctx.lineWidth = 1;
            for (let x = startX; x < camera.x + camera.width; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, camera.y);
                ctx.lineTo(x, camera.y + camera.height);
                ctx.stroke();
            }
            for (let y = startY; y < camera.y + camera.height; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(camera.x, y);
                ctx.lineTo(camera.x + camera.width, y);
                ctx.stroke();
            }
        }

        function updateHUD() {
            timerDisplay.textContent = `Tempo: ${formatTime(gameTime)}`;
            killCountDisplay.textContent = `Abates: ${player.killCount}`;
            coinsCollectedDisplay.textContent = Math.floor(player.coins);
            levelDisplay.textContent = `N√≠vel: ${player.level}`;
            const xpNeeded = getXpForLevel(player.level + 1);
            const xpPercentage = (player.xp / xpNeeded) * 100;
            xpBar.style.width = `${xpPercentage}%`;
        }
        
        function updateActiveWeaponsUI() {
            activeWeaponsUI.innerHTML = '';
            player.weapons.forEach(w => {
                const weaponEl = document.createElement('div');
                weaponEl.className = 'hud-element text-sm px-3 py-1 rounded-md flex items-center gap-2';
                weaponEl.innerHTML = `<span>${w.icon}</span> <span>Nvl ${w.level}</span>`;
                activeWeaponsUI.appendChild(weaponEl);
            });
        }


        // --- METAPROGRESS√ÉO ---
        function saveMetaProgress() {
            const data = {
                totalCoins: totalCoins,
                upgrades: {}
            };
            Object.keys(metaUpgradesList).forEach(key => {
                data.upgrades[key] = { level: metaUpgradesList[key].level };
            });
            localStorage.setItem('horde_survivor_save_2.0', JSON.stringify(data));
        }

        function loadMetaProgress() {
            const savedData = localStorage.getItem('horde_survivor_save_2.0');
            if (savedData) {
                const data = JSON.parse(savedData);
                totalCoins = data.totalCoins || 0;
                 if (data.upgrades) {
                     Object.keys(data.upgrades).forEach(key => {
                         if (metaUpgradesList[key]) {
                             metaUpgradesList[key].level = data.upgrades[key].level || 0;
                         }
                     });
                 }
            }
            Object.keys(metaUpgradesList).forEach(key => {
                metaUpgrades[key] = { level: metaUpgradesList[key].level };
            });
            updateCoinDisplays();
            renderStore();
        }

        function buyMetaUpgrade(key) {
            const upgrade = metaUpgradesList[key];
            const cost = getMetaUpgradeCost(key);
            if (totalCoins >= cost && upgrade.level < upgrade.maxLevel) {
                totalCoins -= cost;
                upgrade.level++;
                metaUpgrades[key].level = upgrade.level;
                saveMetaProgress();
                updateCoinDisplays();
                renderStore();
                playSound(500, 'sine', 0.1);
            } else {
                playSound(150, 'square', 0.2);
            }
        }
        
        function getMetaUpgradeCost(key) {
            const upgrade = metaUpgradesList[key];
            return Math.floor(upgrade.baseCost * Math.pow(1.5, upgrade.level));
        }

        function renderStore() {
            metaUpgradesContainer.innerHTML = '';
            Object.keys(metaUpgradesList).forEach(key => {
                const upgrade = metaUpgradesList[key];
                const cost = getMetaUpgradeCost(key);
                const card = document.createElement('div');
                card.className = 'bg-gray-800 p-4 rounded-lg border border-gray-700 flex flex-col items-center';
                
                const isMaxed = upgrade.level >= upgrade.maxLevel;
                
                card.innerHTML = `
                    <h3 class="text-xl font-bold">${upgrade.name}</h3>
                    <p class="text-sm text-gray-400">N√≠vel ${upgrade.level} / ${upgrade.maxLevel}</p>
                    <p class="text-center my-2 h-10">${upgrade.description}</p>
                    <button class="w-full mt-auto font-bold py-2 px-4 rounded ${isMaxed ? 'bg-green-700 cursor-default' : (totalCoins >= cost ? 'bg-yellow-600 hover:bg-yellow-500' : 'bg-gray-600 cursor-not-allowed')}">
                        ${isMaxed ? 'MAX' : `Custo: <i class="coin-icon">$</i> ${cost}`}
                    </button>
                `;

                if (!isMaxed) {
                    card.querySelector('button').onclick = () => buyMetaUpgrade(key);
                }
                metaUpgradesContainer.appendChild(card);
            });
        }
        
        function updateCoinDisplays() {
            totalCoinsDisplayMain.textContent = totalCoins;
            totalCoinsDisplayStore.textContent = totalCoins;
        }

        function showStore(isFromMain) {
            if(isFromMain) {
                startScreen.classList.add('hidden');
            } else {
                gameOverScreen.classList.add('hidden');
            }
            storeScreen.style.display = 'flex';
        }

        function hideStore() {
            storeScreen.style.display = 'none';
             if (gameRunning || gameOverScreen.classList.contains('hidden')) { // Se o jogo n√£o acabou, volta pra tela inicial
                startScreen.classList.remove('hidden');
            } else { // Se o jogo acabou, volta pra tela de game over
                gameOverScreen.classList.remove('hidden');
            }
        }


        // --- LOOP PRINCIPAL DO JOGO ---
        function gameLoop(timestamp) {
            if (!gameRunning) return;
            if (paused) {
                animationFrameId = requestAnimationFrame(gameLoop);
                return;
            }
            
            const dt = (timestamp - lastTime) / 1000;
            lastTime = timestamp;
            gameTime += dt;
            
            update(dt);
            draw();
            updateHUD();

            // L√≥gica de spawn do chefe
            if (!bossSpawned && gameTime > 300) { // Chefe aos 5 minutos
                bossSpawned = true;
                spawnBoss();
                bossAlert.classList.remove('hidden');
                setTimeout(() => bossAlert.classList.add('hidden'), 3000);
            }
            
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        // --- FUN√á√ïES UTILIT√ÅRIAS ---
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            if (camera) {
                camera.width = canvas.width;
                camera.height = canvas.height;
            }
        }
        function formatTime(seconds) {
            const min = Math.floor(seconds / 60).toString().padStart(2, '0');
            const sec = Math.floor(seconds % 60).toString().padStart(2, '0');
            return `${min}:${sec}`;
        }
        function getXpForLevel(level) {
            if (level < XP_PER_LEVEL.length) return XP_PER_LEVEL[level];
            return 100 + (level - 10) * 50;
        }
         function findClosestEnemy(pos) {
            let closest = null;
            let closestDist = Infinity;
            enemies.forEach(e => {
                const dist = Math.hypot(e.x - pos.x, e.y - pos.y);
                if (dist < closestDist) {
                    closestDist = dist;
                    closest = e;
                }
            });
            return closest;
        }
        function triggerScreenShake(duration, magnitude) {
            screenShake.duration = duration;
            screenShake.magnitude = magnitude;
            screenShake.active = true;
        }

        // --- INICIALIZA√á√ÉO ---
        init();
    });
    </script>
</body>
</html>
